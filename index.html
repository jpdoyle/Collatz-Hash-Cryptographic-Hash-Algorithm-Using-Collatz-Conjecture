<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collatz Hash </title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for aesthetic appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            color: #c9d1d9;
        }
        .container-card {
            background-color: #161b22; /* Slightly lighter dark card */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #30363d;
        }
        .hash-output {
            word-wrap: break-word;
            word-break: break-all;
            background-color: #010409;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div class="container-card p-6 md:p-10 rounded-xl w-full max-w-4xl">
        <h1 class="text-3xl font-bold mb-6 text-center text-blue-400">
                 Collatz Hash: Cryptographic Hash Algorithm
        </h1>

        <!-- Input Section -->
        <div class="space-y-4 mb-8">
            <div>
                <label for="inputText" class="block text-sm font-medium mb-1 text-gray-300">Input Text to Hash</label>
                <textarea id="inputText" rows="4" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-blue-500 focus:border-blue-500 placeholder-gray-400" placeholder="Enter text here (e.g., 'Hello world!') or leave empty for hash of empty string."></textarea>
            </div>

            <div class="flex flex-col sm:flex-row gap-4">
                <div class="w-full sm:w-1/2">
                    <label for="digestSize" class="block text-sm font-medium mb-1 text-gray-300">Digest Size (in bits)</label>
                    <select id="digestSize" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="512" selected>512</option>
                        <option value="384">384</option>
                        <option value="256">256</option>
                    </select>
                </div>
                <div class="w-full sm:w-1/2 flex items-end">
                    <button id="hashButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 shadow-md shadow-blue-500/50">
                        Generate Hash
                    </button>
                </div>
            </div>
        </div>

        <!-- Output Section -->
        <div class="space-y-4">
            <h2 class="text-xl font-semibold text-gray-300">Hash Output</h2>
            <div id="loadingIndicator" class="text-center hidden text-blue-400">
                <p>Calculating hash...</p>
            </div>
            <div id="hashResult" class="hash-output p-4 rounded-lg text-green-400 text-base font-mono overflow-auto min-h-[60px]">
                <!-- Hash will appear here -->
            </div>
            <div id="errorBox" class="p-3 bg-red-800 rounded-lg text-red-300 text-sm hidden">
                <!-- Errors will appear here -->
            </div>
        </div>

        <br>
        <br>
        <h1 class="text-3xl font-bold mb-6 text-center text-blue-400">
                 <a href="https://eprint.iacr.org/2025/1606">Official Documentation</a>
        </h1>


    </div>

    

    <script>
        // --- CONSTANTS ---
        const COLLATZ_HASH_512_INPUT_REPRESENTATION_LENGTH = 128; // Length size block in bits
        const BLOCK_SIZE = 1024; // Block size in bits (1024 bits = 128 bytes)
        const WORD_LENGTH = 32; // Word size in bits
        const WORD_COUNT = 32;
        const BUFFER_COUNT = 10;
        
        // Initial 64-bit BigInt buffers (H0-H9)
        const INITIAL_BUFFERS = [
            0x6a09e667f3bcc908n, 0xbb67ae8584caa73bn, 0x3c6ef372fe94f82bn, 0xa54ff53a5f1d36f1n,
            0x510e527fade682d1n, 0x9b05688c2b3e6c1fn, 0x1f83d9abfb41bd6bn, 0x5be0cd19137e2179n,
            0x0000000000000000n, 0x0000000000000000n
        ];


        // --- UTILITY FUNCTIONS (Adapted for JS Number/BigInt) ---

        /**
         * Converts an array of 64-bit BigInt buffers to a hexadecimal string.
         * @param {BigInt[]} buffers - The hash state buffers.
         * @param {number[]} shuffled10 - The shuffle order for the final digest.
         * @param {number} S - The digest size in bits (256, 384, or 512).
         * @returns {string} The final hexadecimal hash digest.
         */
        const toHexString = (buffers, shuffled10, S) => {
            let combined = "";
            const digestLengthWords = S / 64;
            
            for (let i = 0; i < digestLengthWords; ++i) {
                const bufferIndex = shuffled10[i];
                const value = buffers[bufferIndex];
                
                // Convert BigInt to hex string, padding to 16 characters (64 bits)
                let hex = value.toString(16);
                hex = hex.padStart(16, '0');
                combined += hex;
            }
            return combined;
        };

        /**
         * Performs unsigned 32-bit right rotation (C++ rotr16 implementation).
         * @param {number} x - 32-bit unsigned integer (JS Number).
         * @param {number} r - Rotation amount.
         * @returns {number} 32-bit unsigned integer.
         */
        const rotr16 = (x, r) => ((x >>> r) | (x << (16 - r))) >>> 0;

        /**
         * Performs unsigned 64-bit left rotation (C++ rotl64 implementation).
         * @param {BigInt} x - 64-bit unsigned integer (JS BigInt).
         * @param {number} r - Rotation amount.
         * @returns {BigInt} 64-bit unsigned integer.
         */
        const rotl64 = (x, r) => {
            const rotation = BigInt(r);
            const Big64 = 64n;
            // The result of bitwise operations on BigInt is also a BigInt
            return (x << rotation) | (x >> (Big64 - rotation));
        };
        
        /**
         * Combines two 32-bit parts into a single 64-bit BigInt.
         * @param {number[]} parts - [high_32, low_32] 32-bit unsigned integers.
         * @returns {BigInt} 64-bit unsigned integer.
         */
        const combine32to64 = (parts) => {
            // parts[0] is high 32 bits, parts[1] is low 32 bits
            return (BigInt(parts[0]) << 32n) | BigInt(parts[1]);
        };

        /**
         * Converts a 32-bit binary string (WORD_LENGTH = 32) to a 32-bit unsigned integer.
         * @param {string} binStr - Binary string of length 32.
         * @returns {number} 32-bit unsigned integer.
         */
        const getUint32FromBinaryString = (binStr) => {
            // parseInt is used for conversion, and >>> 0 ensures 32-bit unsigned wrapping.
            return parseInt(binStr, 2) >>> 0;
        };


        // --- CORE HASH PRIMITIVES (Alpha and Beta) ---

        /**
         * Non-linear mixing function 'alpha'. Uses 32-bit unsigned arithmetic.
         * @param {number} x - 32-bit input.
         * @param {number} y - 32-bit input.
         * @param {number} z - 32-bit input.
         * @returns {number} 32-bit unsigned result.
         */
        const alpha = (x, y, z) => {
            // uint32_t t = (uint32_t)((uint32_t)x + (uint32_t)y + ((uint32_t)z << 1));
            let t = (x + y + (z << 1)) >>> 0; 
            // uint32_t r = rotr16(t, 7);
            let r_val = rotr16(t, 7);
            // return (uint32_t)((r ^ x) + (y ^ rotr16(z, 3)));
            let result = (r_val ^ x) + (y ^ rotr16(z, 3));
            return result >>> 0; // Final 32-bit wrapping
        };

        /**
         * Non-linear mixing function 'beta'. Uses 32-bit unsigned arithmetic.
         * @param {number} x - 32-bit input.
         * @param {number} y - 32-bit input.
         * @param {number} z - 32-bit input.
         * @returns {number} 32-bit unsigned result.
         */
        const beta = (x, y, z) => {
            // uint32_t choose = (x & y) ^ ((~x) & z);
            let choose = (x & y) ^ ((~x) & z);
            // uint32_t maj = (x & y) ^ (x & z) ^ (y & z);
            let maj = (x & y) ^ (x & z) ^ (y & z);

            // uint32_t t = (uint32_t)(((uint32_t)choose + (uint32_t)maj + rotr16(x ^ y, 5)) & 0xFFFF);
            let t_add = (choose + maj + rotr16(x ^ y, 5)) >>> 0;
            let t = (t_add & 0xFFFF) >>> 0; // Explicit masking to lower 16 bits, then 32-bit wrapping.

            // return (uint32_t)(t ^ rotr16(z, 11));
            return (t ^ rotr16(z, 11)) >>> 0; // Final 32-bit wrapping
        };


        // --- SHUFFLE LOGIC (From Shuffle.h) ---

        /**
         * Derives step and offset for deterministic shuffle based on input key.
         * @param {string} key - The input string used as a key.
         * @param {number} UpperLimit - The size of the set to shuffle (e.g., 32 or 10).
         * @returns {{s: number, o: number}} Step (s) and Offset (o) values.
         */
        const derive_step_and_offset = (key, UpperLimit) => {
            let sum1 = 0; // sum of even indices
            let sum2 = 0; // sum of odd indices
            for (let i = 0; i < key.length; ++i) {
                const charCode = key.charCodeAt(i);
                if (i % 2 === 0)
                    sum1 += charCode;
                else
                    sum2 += charCode;
            }

            // s is odd and between 1 and UpperLimit - 1 (approx)
            // C++: s = (sum1 % UpperLimit/2) * 2 + 1;
            let s = (Math.floor(sum1 % (UpperLimit / 2)) * 2) + 1;
            // o is offset from 0 to UpperLimit - 1
            let o = sum2 % UpperLimit;
            
            // Ensure s is at least 1 (though logic should prevent 0)
            if (s === 0) s = 1;

            return { s, o };
        };

        /**
         * Performs a modular shuffle of indices [0...UpperLimit-1] using s and o.
         * @param {string} key - The input string used as a key.
         * @param {number} UpperLimit - The size of the set to shuffle (e.g., 32 or 10).
         * @returns {number[]} The shuffled array of indices [0...UpperLimit-1].
         */
        const deterministic_shuffle = (key, UpperLimit) => {
            // Note: If key is empty, sum1/sum2 will be 0, resulting in s=1, o=0. This is a valid deterministic shuffle.
            const { s, o } = derive_step_and_offset(key, UpperLimit);

            const result = [];
            for (let k = 0; k < UpperLimit; ++k) {
                // val = (offset + index * step) % UpperLimit
                let val = (o + k * s) % UpperLimit;
                result.push(val);
            }
            return result;
        };


        // --- PADDING LOGIC (From Collatz-Hash-6.h) ---

        /**
         * Performs MD-style padding (append '1' bit, zeros, then 128-bit length).
         * @param {string} input - The original message string.
         * @returns {string} The padded message as a binary string (multiple of BLOCK_SIZE).
         */
        const collatzHash512Padding = (input) => {
            // 1. Convert input string to binary
            let finalPlainText = "";
            for (let i = 0; i < input.length; ++i) {
                // Convert each character's charCode to an 8-bit binary string
                finalPlainText += input.charCodeAt(i).toString(2).padStart(8, '0');
            }

            // 2. Append '1' bit (the mark bit)
            finalPlainText += '1';

            // Original message length in bits (BigInt)
            const plainTextSizeBits = BigInt(input.length) * 8n;

            // 3. Calculate zero padding length
            const L_msg_plus_1 = finalPlainText.length; // Length after data + '1' bit
            
            // We need L_msg_plus_1 + L_zeros + 128 to be a multiple of BLOCK_SIZE (1024)
            const totalLengthModulo = (L_msg_plus_1 + COLLATZ_HASH_512_INPUT_REPRESENTATION_LENGTH) % BLOCK_SIZE;

            let numberOfZeros = 0;
            if (totalLengthModulo !== 0) {
                 numberOfZeros = BLOCK_SIZE - totalLengthModulo;
            }

            // 4. Append zeros
            finalPlainText += '0'.repeat(numberOfZeros);

            // 5. Append original message length (as 128-bit binary string)
            const lengthBinary = plainTextSizeBits.toString(2).padStart(COLLATZ_HASH_512_INPUT_REPRESENTATION_LENGTH, '0');
            finalPlainText += lengthBinary;

            return finalPlainText;
        };


        // --- MAIN HASH FUNCTION ---

        /**
         * The main Collatz Hash 6 algorithm implementation.
         * @param {string} inp - The message string to hash.
         * @param {number} S - The desired digest size (256, 384, or 512).
         * @returns {string} The hexadecimal hash digest.
         */
        const collatz_Hash_6 = (inp, S) => {
            if (![256, 384, 512].includes(S)) {
                throw new Error("Invalid digest size. Must be 256, 384, or 512.");
            }
            
            // Initialize buffers: creates a copy of the BigInt buffers
            const buffers = [...INITIAL_BUFFERS]; 
            const input = inp;
            const key = input; // Key for shuffling is the input message itself

            // Generate deterministic shuffles
            const shuffled32 = deterministic_shuffle(key, 32);
            const shuffled10 = deterministic_shuffle(key, 10);

            // Pad the input message
            const paddedInput = collatzHash512Padding(input);

            let T1 = 0n;
            let T2 = 0n;

            // Process message blocks (1024 bits = 128 bytes)
            for (let n = 0; n < paddedInput.length; n += BLOCK_SIZE) {
                const currentBlock = paddedInput.substring(n, n + BLOCK_SIZE);
                
                // 1. Prepare W (Message Schedule Words - 32 x 32-bit words)
                const W = [];
                for (let j = 0; j < WORD_COUNT; ++j) {
                    const binStr = currentBlock.substring(j * WORD_LENGTH, (j + 1) * WORD_LENGTH);
                    W[j] = getUint32FromBinaryString(binStr);
                }
                
                // W_big is W converted to BigInt for 64-bit operations
                const W_big = W.map(w => BigInt(w));

                // 2. Initialize working variables (a-h are 64-bit BigInts)
                let a = buffers[0], b = buffers[1], c = buffers[2], d = buffers[3];
                let e = buffers[4], f = buffers[5], g = buffers[6], h = buffers[7];

                // Declare 32-bit parts arrays (matching C++ declaration style)
                let a_parts = new Array(2), b_parts = new Array(2), c_parts = new Array(2), d_parts = new Array(2);
                let e_parts = new Array(2), f_parts = new Array(2), g_parts = new Array(2), h_parts = new Array(2);

                // Split 64-bit buffers into 32-bit parts (high 32 bits and low 32 bits)
                // This ensures each 64-bit buffer (a-h) is correctly represented by its parts.
                const split64 = (val, parts) => {
                    parts[0] = (Number(val >> 32n) >>> 0);  // High 32 bits
                    parts[1] = (Number(val & 0xFFFFFFFFn) >>> 0); // Low 32 bits
                };

                split64(a, a_parts); split64(b, b_parts); split64(c, c_parts); split64(d, d_parts);
                split64(e, e_parts); split64(f, f_parts); split64(g, g_parts); split64(h, h_parts);
                
                
                // 3. Initialize X array (16 elements, 32-bit uints)
                // X combines the 32-bit parts of a-h
                const X = new Array(16);
                X[0] = a_parts[0]; X[4] = c_parts[0]; X[8] = e_parts[0];  X[12] = g_parts[0];
                X[1] = a_parts[1]; X[5] = c_parts[1]; X[9] = e_parts[1];  X[13] = g_parts[1];
                X[2] = b_parts[0]; X[6] = d_parts[0]; X[10] = f_parts[0]; X[14] = h_parts[0];
                X[3] = b_parts[1]; X[7] = d_parts[1]; X[11] = f_parts[1]; X[15] = h_parts[1];

                // 4. Mix X array (similar to SHA-2 round logic)
                for (let i = 0; i < 16; i++) {
                    const left = X[(i + 15) % 16];
                    const right = X[(i + 1) % 16];
                    
                    // rotation offsets vary to avoid symmetry
                    const mix_add = left + rotr16(right, (i & 3) + 3);
                    const mix = (mix_add & 0xFFFF) >>> 0; 

                    // XOR + add for nonlinearity
                    X[i] = (X[i] ^ rotr16(mix, (i & 0xF))) >>> 0;
                }
                
                // 5. Main Collatz Loop (7 rounds: w=0 to w=6)
                for (let w = 0; w <= 6; w++) {
                    // Extract 16-bit value 'x' from 32-bit word in X, alternating high/low 16 bits
                    let x_source = X[shuffled32[w] % 16];
                    let x;
                    if (w % 2 === 0) {
                        // Even rounds: Use low 16 bits
                        x = x_source & 0xFFFF;
                    } else {
                        // Odd rounds: Use high 16 bits
                        x = (x_source >>> 16) & 0xFFFF;
                    }
                    
                    let x_ = x; // Keep original x for T1/T2 calculation later

                    // Collatz Sequence Iteration
                    while (x >= 2) {
                        const r = (x % 2 === 0) ? x % 7 : x % 13;
                        const fn = (x % 2 === 0) ? alpha : beta;

                        // Apply the chosen function (alpha or beta) to all 16 pairs of 32-bit registers (a_parts to h_parts)
                        a_parts[0] = fn(a_parts[0], W[shuffled32[0]], rotr16(W[shuffled32[16]], r));
                        a_parts[1] = fn(a_parts[1], W[shuffled32[1]], rotr16(W[shuffled32[17]], r));
                        b_parts[0] = fn(b_parts[0], W[shuffled32[2]], rotr16(W[shuffled32[18]], r));
                        b_parts[1] = fn(b_parts[1], W[shuffled32[3]], rotr16(W[shuffled32[19]], r));
                        c_parts[0] = fn(c_parts[0], W[shuffled32[4]], rotr16(W[shuffled32[20]], r));
                        c_parts[1] = fn(c_parts[1], W[shuffled32[5]], rotr16(W[shuffled32[21]], r));
                        d_parts[0] = fn(d_parts[0], W[shuffled32[6]], rotr16(W[shuffled32[22]], r));
                        d_parts[1] = fn(d_parts[1], W[shuffled32[7]], rotr16(W[shuffled32[23]], r));
                        e_parts[0] = fn(e_parts[0], W[shuffled32[8]], rotr16(W[shuffled32[24]], r));
                        e_parts[1] = fn(e_parts[1], W[shuffled32[9]], rotr16(W[shuffled32[25]], r));
                        f_parts[0] = fn(f_parts[0], W[shuffled32[10]], rotr16(W[shuffled32[26]], r));
                        f_parts[1] = fn(f_parts[1], W[shuffled32[11]], rotr16(W[shuffled32[27]], r));
                        g_parts[0] = fn(g_parts[0], W[shuffled32[12]], rotr16(W[shuffled32[28]], r));
                        g_parts[1] = fn(g_parts[1], W[shuffled32[13]], rotr16(W[shuffled32[29]], r));
                        h_parts[0] = fn(h_parts[0], W[shuffled32[14]], rotr16(W[shuffled32[30]], r));
                        h_parts[1] = fn(h_parts[1], W[shuffled32[15]], rotr16(W[shuffled32[31]], r));
                        
                        // Update x based on Collatz sequence rule
                        x = (x % 2 === 0) ? x / 2 : ((3 * x) + 1) / 2;
                    }

                    // Re-combine 32-bit parts into 64-bit working variables
                    a = combine32to64(a_parts);
                    b = combine32to64(b_parts);
                    c = combine32to64(c_parts);
                    d = combine32to64(d_parts);
                    e = combine32to64(e_parts);
                    f = combine32to64(f_parts);
                    g = combine32to64(g_parts);
                    h = combine32to64(h_parts);

                    // 6. Final Block Mix (uses x_ for indexing)
                    T1 = a ^ W_big[(x_ + 3) % 32];
                    b = a ^ W_big[x_ % 32];
                    c = b ^ T1;
                    d = c ^ rotl64(T1, 29);
                    e = d ^ rotl64(T1, 41);
                    T2 = e ^ W_big[(x_ + 2) % 32];
                    f = e ^ W_big[(x_ + 5) % 32];
                    g = f ^ T2;
                    h = g ^ rotl64(T2, 53);
                    a = h ^ rotl64(T2, 13);
                    
                    // 7. Update buffers (Addition wraps automatically for BigInt) - Applies every round
                    // This is the first of the two buffer updates observed in the C++ logic.
                    buffers[0] += a; buffers[1] += b; buffers[2] += c; buffers[3] += d;
                    buffers[4] += e; buffers[5] += f; buffers[6] += g; buffers[7] += h;
                    buffers[8] += T1; buffers[9] += T2;
                } // End of w loop (7 rounds)
                
                // 8. Final Mixing Step (Recalculation if it is the last block)
                const isLastBlock = n + BLOCK_SIZE >= paddedInput.length;
                if (isLastBlock) {
                    // C++ logic recalculates T1/T2 and a-h using message words and the block index 'n'
                    // Note: n % 32 will always be 0 since n is a multiple of 1024, using W[0], W[5], W[1], W[7]
                    T1 = a ^ W_big[n % 32];
                    b = a ^ W_big[(n + 5) % 32];
                    c = b ^ T1;
                    d = c ^ rotl64(T1, 29);
                    e = d ^ rotl64(T1, 41);
                    T2 = e ^ W_big[(n + 1) % 32];
                    f = e ^ W_big[(n + 7) % 32];
                    g = f ^ T2;
                    h = g ^ rotl64(T2, 53);
                    a = h ^ rotl64(T2, 13);
                }
                
                // 9. Final Buffer Update (Applies to EVERY block, using the values from Step 6 or Step 8)
                // This is the second, unconditional buffer update after the optional last block mix.
                buffers[0] += a; buffers[1] += b; buffers[2] += c; buffers[3] += d;
                buffers[4] += e; buffers[5] += f; buffers[6] += g; buffers[7] += h;
                buffers[8] += T1; buffers[9] += T2;
            }

            // 10. Final Digest Output
            const combinedHex = toHexString(buffers, shuffled10, S);
            return combinedHex;
        };


        // --- UI / EVENT LOGIC ---
        document.getElementById('hashButton').addEventListener('click', () => {
            const inputText = document.getElementById('inputText').value;
            const digestSize = parseInt(document.getElementById('digestSize').value, 10);
            const hashResultEl = document.getElementById('hashResult');
            const loadingIndicatorEl = document.getElementById('loadingIndicator');
            const errorBoxEl = document.getElementById('errorBox');
            
            hashResultEl.textContent = '';
            errorBoxEl.textContent = '';
            errorBoxEl.classList.add('hidden');
            loadingIndicatorEl.classList.remove('hidden');

            // Use a short delay to ensure loading state is rendered
            setTimeout(() => {
                try {
                    // Use the raw input string. Cryptographic hash functions must support empty/whitespace-only input.
                    const inputToHash = inputText; 
                    
                    const hash = collatz_Hash_6(inputToHash, digestSize);
                    hashResultEl.textContent = hash;
                } catch (e) {
                    errorBoxEl.textContent = `Error: ${e.message}`;
                    errorBoxEl.classList.remove('hidden');
                    console.error("Hash calculation failed:", e);
                    hashResultEl.textContent = 'Error during calculation.';
                } finally {
                    loadingIndicatorEl.classList.add('hidden');
                }
            }, 10); // Minimum delay
        });
        
        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            // Placeholder text on load
            document.getElementById('hashResult').textContent = 'Enter text and click "Generate Hash" to see the result.';
        });

    </script>
    
</body>
</html>
